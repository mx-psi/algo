\section{El problema del viajante de comercio}

El problema del viajante de comercio consiste en hallar el recorrido con distancia
mínima en un conjunto de ciudades que pase por todas las ciudades y regrese al punto
inicial. \\

La implementación de los algoritmos es de la forma:
\begin{description}
 \item[Entrada:] Ficheros con ciudades indicadas como puntos en el plano según sus
 coordenadas.
 \item[Salida:] \texttt{vector<int>} con el orden en el que se recorren las ciudades.
\end{description}

En la salida nos ahorraremos repetir el primer nodo al final del recorrido.

Para todos los algoritmos utilizaremos una estructura de datos que nos permita manejar
el problema: la clase \texttt{Grafo} (en el fichero \texttt{grafo.h}). Un grafo consta
de:

\begin{itemize}
  \item Una \textbf{cantidad de nodos}, almacenada en el atributo \texttt{nodos}.
  \item Una \textbf{matriz de pesos}, almacenada en el vector \texttt{lados}.
\end{itemize}

La interfaz nos permite acceder y modificar estos datos con mayor facilidad.
Mediante los métodos \texttt{setPeso} y \texttt{peso} accederemos al peso de un
lado del grafo, y el método \texttt{pesosDesdeCoordenadas} nos permite inicializar el
grafo utilizando el formato de datos en el que aparece el problema: calculando
la distancia entre cualesquiera dos ciudades y añadir esta como peso de ese lado:

\lstinputlisting[firstline=47, lastline=51]{cpps/grafo.h}

Adicionalmente, la función \texttt{longitud} calcula la longitud de un camino dado,
teniendo en cuenta la distancia del último nodo al primero:

\lstinputlisting[firstline=54, lastline=59]{cpps/grafo.h}

Siendo \texttt{peso\_t} el tipo de dato con el que se manejen las distancias entre
nodos. Según el enunciado del problema (que pide que se redondee la distancia
euclídea al entero más próximo), será de tipo \texttt{int}.

\subsection{Ramificación y acotación}

El primer tipo de algoritmos a analizar son los algoritmos de ramificación y acotación
(\textit{branch and bound}). Estos algoritmos exploran un árbol de caminos parciales (en el que los hijos de un nodo añaden una ciudad no visitada) pero expandiendo sólo aquellos nodos para los que existe la posibilidad de que haya una solución mejor que la mejor
encontrada hasta el momento.

En primer lugar veremos el algoritmo de ramificación y acotación para una cota general y por último veremos la implementación de las cotas que hemos utilizado.

\subsubsection{Algoritmo general}

Presentamos en esta sección un algoritmo general que implementa el \textit{branch and bound} dada una cota. Utilizaremos este mismo algoritmo variando únicamente la cota para las dos implementaciones. En casos particulares en los que existe una forma eficiente de obtener la cota de una solución parcial a partir de la de su padre (la solución parcial que tiene todas las ciudades menos la última), podrían hacerse pequeñas modificaciones de este algoritmo para optimizar el cálculo de la misma.

El algoritmo toma un \texttt{Grafo} y una función \texttt{cota}. Esta última calcula dado un camino (y el grafo) un entero que sea menor o igual que la mejor solución posible que pueda obtenerse añadiendo nuevas ciudades a la solución parcial.

En primer lugar iniciamos la cola con prioridad introduciendo la solución parcial
inicial (\texttt{[0]}). Para optimizar el cálculo guardamos también en la cola el valor de la cota para cada nodo que introducimos. Inicializamos también la mejor solución encontrada con un algoritmo greedy (en este caso vecino más cercano).

%% TODO (Cuando no se muevan las lineas): Código de la primera parte

A partir de aquí, mientras la cola no esté vacía cogemos el nodo en el frente (aquel con menor cota), y distinguimos dos casos:

Si \textbf{basta añadir 2 ciudades para hallar un camino}, creamos todos los caminos posibles y comprobamos, para cada uno de ellos, si es mejor que la mejor solución encontrada hasta el momento, y en tal caso actualizamos. Esto permite no añadir más nodos a la cola de prioridad y genera una ligera mejora en los tiempos de ejecución.

%% TODO (Cuando no se muevan las lineas): Código del caso hojas

En el caso de que no baste añadir 2 ciudades a la solución parcial que estamos considerando, para cada ciudad no visitada consideramos el camino que resulta de añadir esta ciudad al final de la solución parcial. Si la nueva solución tiene una cota menor que la de la mejor solución la insertamos ordenadamente en la cola:

%% TODO (Cuando no se muevan las lineas): Código del caso de branch

Repetimos este proceso y devolvemos el mejor camino encontrado. El algoritmo completo queda:

%% TODO (Cuando no se muevan las lineas): Código completo

\subsubsection{Cotas}

Para implementar la cota dada por el enunciado utilizamos una función auxiliar \texttt{RelacionadosCon} que nos indica dada una ciudad, cuál es el conjunto de ciudades que debemos considerar para calcular la cota:

\lstinputlisting[firstline=43, lastline=51]{cpps/tsp.cpp}

De esta forma para calcular la primera cota basta con calcular la longitud del recorrido inicial y sumar la menor distancia de cada ciudad no incluida en la solución parcial con sus relacionadas:

\lstinputlisting[firstline=54, lastline=73]{cpps/tsp.cpp}

En la otra cota nos pedían una original, y hemos optado por usar lo que sabíamos de árboles generadores minimales de los grafos. Así que la segunda cota coge el recorrido del camino parcial que tenías hasta ese momento y le suma el recorrido del árbol generador minimal de los nodos que faltan por meter junto al último nodo del camino. Como el árbol generador minimal es la forma más corta de comunicar los nodos que faltan, no vamos a poder realizar un camino que pase por ellos que sea menor que eso, así que es una cota real del camino mínimo.

Para calcular la cota usamos el algoritmo de Kruskal, que toma en cuenta el peso de las aristas y las va cogiendo en orden, cuidando que no formen ciclos. Se puede ver que el método no dista mucho de la primera cota, puesto que muchas de las aristas que coja el primero se cogerán en este, ya que las ordenan por la misma comparación. Hay que notar que la primera cota podía formar ciclos o incluso no llegar a formar un camino, mientras que esta segunda cota mantiene al menos una conexión entre los nodos.

Si bien ganamos en la acotación %% TODO: (Antonio) Comprobar que de verdad se gana, que no estoy seguro)
la eficiencia es algo peor que en el primer caso. Debido a que el algoritmo se vuelve inservible a partir de muy pocos nodos (cerca de 16), la eficiencia de la cota en función de los nodos no debería afectar tanto al resultado. %% Aunque sí que afecta, JAJ
\subsection{Vuelta atrás}

%% TODO: (Iñaki) Descripción del algoritmo de backtracking

\subsection{Comparativa de los algoritmos}

%%% TODO (Iñaki)
% Gráficas que comparen entre los 3 algoritmos:
% - Número de nodos expandidos
% - Tamaño máximo de la cola con prioridad
% - Número de veces que se realiza la poda
% - Tiempo empleado en resolver el problema
%%%
