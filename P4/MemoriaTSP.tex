\section{El problema del viajante de comercio}

El problema del viajante de comercio consiste en hallar el recorrido con distancia
mínima en un conjunto de ciudades que pase por todas las ciudades y regrese al punto
inicial. \\

La implementación de los algoritmos es de la forma:
\begin{description}
 \item[Entrada:] Ficheros con ciudades indicadas como puntos en el plano según sus
 coordenadas.
 \item[Salida:] \texttt{vector<int>} con el orden en el que se recorren las ciudades.
\end{description}

En la salida nos ahorraremos repetir el primer nodo al final del recorrido.

Para todos los algoritmos utilizaremos una estructura de datos que nos permita manejar
el problema: la clase \texttt{Grafo} (en el fichero \texttt{grafo.h}). Un grafo consta
de:

\begin{itemize}
  \item Una \textbf{cantidad de nodos}, almacenada en el atributo \texttt{nodos}.
  \item Una \textbf{matriz de pesos}, almacenada en el vector \texttt{lados}.
\end{itemize}

La interfaz nos permite acceder y modificar estos datos con mayor facilidad.
Mediante los métodos \texttt{setPeso} y \texttt{peso} accederemos al peso de un
lado del grafo, y el método \texttt{pesosDesdeCoordenadas} nos permite inicializar el
grafo utilizando el formato de datos en el que aparece el problema: calculando
la distancia entre cualesquiera dos ciudades y añadir esta como peso de ese lado:

\lstinputlisting[firstline=47, lastline=51]{cpps/grafo.h}

Adicionalmente, la función \texttt{longitud} calcula la longitud de un camino dado,
teniendo en cuenta la distancia del último nodo al primero:

\lstinputlisting[firstline=54, lastline=59]{cpps/grafo.h}

Siendo \texttt{peso\_t} el tipo de dato con el que se manejen las distancias entre
nodos. Según el enunciado del problema (que pide que se redondee la distancia
euclídea al entero más próximo), será de tipo \texttt{int}.

\subsection{Ramificación y acotación}

El primer tipo de algoritmos a analizar son los algoritmos de ramificación y acotación
(\textit{branch and bound}). Estos algoritmos exploran un árbol de caminos parciales (en el que los hijos de un nodo añaden una ciudad no visitada) pero expandiendo sólo aquellos nodos para los que existe la posibilidad de que haya una solución mejor que la mejor
encontrada hasta el momento.

Para ello hemos utilizado una cola con prioridad que presenta una operación adicional
que presentaremos a continuación. Posteriormente veremos el algoritmo de ramificación
y acotación para una cota general y por último veremos la implementación de las cotas
que hemos utilizado.

\subsubsection{Cola con prioridad}

El algoritmo de ramificación y acotación utiliza una cola con prioridad para guardar
los nodos a explorar, ordenados por una cota (el nodo con menor cota aparecerá el
primero en la cola).

En un primer lugar utilizamos la cola con prioridad que proporciona la STL (\texttt{priority\_queue}), que implementa las operaciones \texttt{top}, \texttt{push}, \texttt{pop} y \texttt{size}. La interfaz de esta estructura de datos no proporciona una forma de borrar los nodos muertos (aquellos cuya cota es peor que la longitud de la mejor solución encontrada hasta el momento), por lo que inicialmente decidimos no borrar estos nodos y simplemente ignorarlos. Tras realizar pruebas nos dimos cuenta de que el
uso de memoria del programa era excesivo y esto hacía que las inserciones y borrados fueran demasiado lentos, por lo que hemos construido una estructura simple que añade esta nueva operación, mejorando, en el caso de \texttt{ulysses16} de más de 15 minutos a menos de un minuto.

Dado que la eficiencia de las operaciones es crucial en este caso, la estructura de datos implementada sigue a grandes rasgos la implementación de \texttt{priority\_queue}, ya que consideramos que es difícil de mejorar y nos permitía implementar la nueva operación fácilmente. La clase implementada es la siguiente:

\lstinputlisting[firstline=11, lastline=34]{cpps/cola.h}

Para todas las operaciones utilizamos una clase funtor \texttt{Compare} que implementa
la operación de comparación entre las soluciones parciales: un nodo se considera con más prioridad que otro si su cota es menor.

La implementación utiliza las operaciones \texttt{push\_heap} y \texttt{pop\_heap}, que implementan
de forma efectiva las operaciones \texttt{push} y \texttt{pop} de una cola con prioridad sobre un \texttt{vector} con eficiencia logarítmica.

En el caso de \texttt{remove\_less\_than} utilizamos la función \texttt{lower\_bound},
que realiza un algoritmo muy similar a la búsqueda binaria para encontrar en tiempo
logarítmico el primer elemento del vector que es mayor o igual que uno dado.

\subsubsection{Algoritmo general}

Presentamos en esta sección un algoritmo general que implementa el \textit{branch and bound} dada una cota. Utilizaremos este mismo algoritmo variando únicamente la cota para las dos implementaciones. En casos particulares en los que existe una forma eficiente de obtener la cota de una solución parcial a partir de la de su padre (la solución parcial que tiene todas las ciudades menos la última), podrían hacerse pequeñas modificaciones de este algoritmo para optimizar el cálculo de la misma.

El algoritmo toma un \texttt{Grafo} y una función \texttt{cota}. Esta última calcula dado un camino (y el grafo) un entero que sea menor o igual que la mejor solución posible que pueda obtenerse añadiendo nuevas ciudades a la solución parcial.

En primer lugar iniciamos la cola con prioridad introduciendo la solución parcial
inicial (\texttt{[0]}). Para optimizar el cálculo guardamos también en la cola el valor de la cota para cada nodo que introducimos. Inicializamos también la mejor solución encontrada con un algrotimo greedy (en este caso vecino más cercano).

%% TODO (Cuando no se muevan las lineas): Código de la primera parte

A partir de aquí, mientras la cola no esté vacía cogemos el nodo en el frente (aquel con menor cota), y distinguimos dos casos:

Si \textbf{basta añadir 2 ciudades para hallar un camino}, creamos todos los caminos posibles y comprobamos, para cada uno de ellos, si es mejor que la mejor solución encontrada hasta el momento, y en tal caso actualizamos. Esto permite no añadir más nodos a la cola de prioridad y genera una ligera mejora en los tiempos de ejecución.

%% TODO (Cuando no se muevan las lineas): Código del caso hojas

Cuando encontramos una solución mejor que la encontrada hasta el momento, borramos todos los nodos de la que tengan peor cota que este de la cola con prioridad.

En el caso de que no baste añadir 2 ciudades a la solución parcial que estamos considerando, para cada ciudad no visitada consideramos el camino que resulta de añadir esta ciudad al final de la solución parcial. Si la nueva solución tiene una cota menor que la de la mejor solución la insertamos ordenadamente en la cola:

%% TODO (Cuando no se muevan las lineas): Código del caso de branch

Repetimos este proceso y devolvemos el mejor camino encontrado. El algoritmo completo queda:

%% TODO (Cuando no se muevan las lineas): Código completo

\subsubsection{Cotas}

% TODO (Antonio): Cota del árbol generador minimal

\subsection{Vuelta atrás}

%% TODO: Descripción del algoritmo de backtracking

\subsection{Comparativa de los algoritmos}

%%% TODO (Iñaki)
% Gráficas que comparen entre los 3 algoritmos:
% - Número de nodos expandidos
% - Tamaño máximo de la cola con prioridad
% - Número de veces que se realiza la poda
% - Tiempo empleado en resolver el problema
%%%
