\section{El problema del viajante de comercio}

El problema del viajante de comercio consiste en hallar el recorrido con distancia
mínima en un conjunto de ciudades que pase por todas las ciudades y regrese al punto
inicial. \\

La implementación de los algoritmos es de la forma:
\begin{description}
 \item[Entrada:] Ficheros con ciudades indicadas como puntos en el plano según sus
 coordenadas.
 \item[Salida:] \texttt{vector<int>} con el orden en el que se recorren las ciudades.
\end{description}

En la salida nos ahorraremos repetir el primer nodo al final del recorrido.

Para todos los algoritmos utilizaremos una estructura de datos que nos permita manejar
el problema: la clase \texttt{Grafo} (en el fichero \texttt{grafo.h}). Un grafo consta
de:

\begin{itemize}
  \item Una \textbf{cantidad de nodos}, almacenada en el atributo \texttt{nodos}.
  \item Una \textbf{matriz de pesos}, almacenada en el vector \texttt{lados}.
\end{itemize}

La interfaz nos permite acceder y modificar estos datos con mayor facilidad.
Mediante los métodos \texttt{setPeso} y \texttt{peso} accederemos al peso de un
lado del grafo, y el método \texttt{pesosDesdeCoordenadas} nos permite inicializar el
grafo utilizando el formato de datos en el que aparece el problema: calculando
la distancia entre cualesquiera dos ciudades y añadir esta como peso de ese lado:

\lstinputlisting[firstline=47, lastline=51]{cpps/grafo.h}

Adicionalmente, la función \texttt{longitud} calcula la longitud de un camino dado,
teniendo en cuenta la distancia del último nodo al primero:

\lstinputlisting[firstline=54, lastline=59]{cpps/grafo.h}

Siendo \texttt{peso\_t} el tipo de dato con el que se manejen las distancias entre
nodos. Según el enunciado del problema (que pide que se redondee la distancia
euclídea al entero más próximo), será de tipo \texttt{int}.

\subsection{Ramificación y acotación}

El primer tipo de algoritmos a analizar son los algoritmos de ramificación y acotación
(\textit{branch and bound}). Estos algoritmos exploran un árbol de caminos parciales (en el que los hijos de un nodo añaden una ciudad no visitada) pero expandiendo sólo aquellos nodos para los que existe la posibilidad de que haya una solución mejor que la mejor
encontrada hasta el momento.

Para ello hemos utilizado una cola con prioridad que presenta una operación adicional
que presentaremos a continuación. Posteriormente veremos el algoritmo de ramificación
y acotación para una cota general y por último veremos la implementación de las cotas
que hemos utilizado.

\subsubsection{Cola con prioridad}

El algoritmo de ramificación y acotación utiliza una cola con prioridad para guardar
los nodos a explorar, ordenados por una cota (el nodo con menor cota aparecerá el
primero en la cola).

En un primer lugar utilizamos la cola con prioridad que proporciona la STL (\texttt{priority\_queue}), que implementa las operaciones \texttt{top}, \texttt{push}, \texttt{pop} y \texttt{size}. La interfaz de esta estructura de datos no proporciona una forma de borrar los nodos muertos (aquellos cuya cota es peor que la longitud de la mejor solución encontrada hasta el momento), por lo que inicialmente decidimos no borrar estos nodos y simplemente ignorarlos. Tras realizar pruebas nos dimos cuenta de que el
uso de memoria del programa era excesivo, por lo que hemos construido una estructura simple que añade esta nueva operación, mejorando, en el caso de \texttt{ulysses16} de más de 15 minutos a menos de un minuto.

Dado que la eficiencia de las operaciones es crucial en este caso, la estructura de datos implementada sigue a grandes rasgos la implementación de \texttt{priority\_queue}, ya que consideramos que es difícil de mejorar y nos permitía implementar la nueva operación fácilmente. La clase implementada es la siguiente:

\lstinputlisting[firstline=11, lastline=34]{cpps/cola.h}

Para todas las operaciones utilizamos una clase funtor \texttt{Compare} que implementa
la operación de comparación entre las soluciones parciales: un nodo se considera con más prioridad que otro si su cota es menor.

La implementación utiliza las operaciones \texttt{push\_heap} y \texttt{pop\_heap}, que implementan
de forma efectiva las operaciones \texttt{push} y \texttt{pop} de una cola con prioridad sobre un \texttt{vector} con eficiencia logarítmica.

En el caso de \texttt{remove\_less\_than} utilizamos la función \texttt{lower\_bound},
que realiza un algoritmo muy similar a la búsqueda binaria para encontrar en tiempo
logarítmico el primer elemento del vector que es mayor o igual que uno dado.

\subsubsection{Algoritmo general}

% TODO (Pablo): Descripción del algoritmo general

\subsubsection{Cotas}

% TODO (Antonio): Cota del árbol generador minimal

\subsection{Vuelta atrás}

%% TODO: Descripción del algoritmo de backtracking

\subsection{Comparativa de los algoritmos}

%%% TODO (Iñaki)
% Gráficas que comparen entre los 3 algoritmos:
% - Número de nodos expandidos
% - Tamaño máximo de la cola con prioridad
% - Número de veces que se realiza la poda
% - Tiempo empleado en resolver el problema
%%%
