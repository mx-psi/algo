\section{Estación de ITV}

En este problema se presenta una estación de ITV de $m$ líneas, entre las que
se pretende repartir un grupo de $n$ coches tales que cada coche requiere un
tiempo de inspección $T_i$ (independiente de la línea a la que se haya asignado)
de forma que el tiempo transcurrido desde el inicio hasta que terminen las
inspecciones sea mínimo. Por ello, se buscará organizar los coches en las $m$
líneas buscando que el máximo de la suma de los tiempos de inspección de cada
línea sea mínimo. \\

La implementación de los algoritmos es de la forma:
\begin{description}
\item[Entrada:] Vector de tiempos de los coches $T$ y número de líneas $m$
\item[Salida:] Vector que indica en la posición $i$ a qué línea va el coche $i$-ésimo
\end{description}

Proponemos un algoritmo que vaya asignando cada vehículo a cada línea, guarde la solución con el mínimo tiempo que se haya encontrado y vuelva atrás cuando la solución actual no pueda ser mejor que la de menor tiempo encontrada hasta el momento. \\

Para obtener una cota inicial utilizaremos un algoritmo greedy, que se limita a insertar cada coche, por orden de mayor a menor tiempo, en la línea que menos ocupada se encuentre. El orden escogido busca que sea más fácil nivelar las líneas:

\lstinputlisting[firstline=38, lastline=67]{cpps/itv.cpp} % TODO: comprobar que no se mueva el código

El algoritmo vuelta atrás propuesto mantiene un vector de enteros, \texttt{elegidos}, que indica en la posición $i$ a qué línea va el coche $i$. Además tiene un vector de enteros, \texttt{asignados}, que mantiene asignaciones incompletas, en las que solo los primeros elementos tienen líneas asignadas, y un vector de tiempos, \texttt{pesos\_asignados}, que mantiene cuánto tiempo asignado tiene cada línea conforme evoluciona el vector de asignaciones incompleto. Aprovechando que las líneas son iguales, supone que el primer vehículo va a la línea 0.

\lstinputlisting[firstline=69, lastline=83]{cpps/itv.cpp} % TODO: comprobar que no se mueva el código

A continuación se ejecuta un algoritmo recursivo que intenta añadir el último elemento asignado a cada una de las líneas disponibles siempre que esto no provoque que esa línea pase a tener un tiempo asignado mayor que el tiempo máximo de la mejor solución encontrada hasta el momento (que, al inicio de la ejecución del algoritmo, se fija a una solución encontrada por el algoritmo greedy). Además, se evita añadir elementos en una línea si alguna línea anterior se encuentra vacía, dado que las soluciones obtenidas a partir de esa posición serían iguales que las obtenidas colocando ese coche en la anterior salvo permutación de ambas líneas.

\lstinputlisting[firstline=19, lastline=37]{cpps/itv.cpp} % TODO: comprobar que no se mueva el código

Puede observarse que la función de factibilidad consiste en comprobar que la línea donde se piense insertar el coche no tome más peso que el máximo de la mejor solución encontrada, sin comprobar que esto tampoco ocurra en el resto de líneas, pero esto sí se comprueba a la hora de determinar si una solución completa es la mejor solución. Que la función de factibilidad solo compruebe la línea donde se va a insertar se debe a que esta comprobación es mucho más rápida y compensa el mayor número de ramas que se exploran, mientras que es necesario hallar la cota exacta en la solución completa porque la última línea a la que se haya asignado un vehículo podría no ser la que esté más ocupada, y es necesario calcular la cota exacta.



% TODO: estudio empírico de la eficiencia

% TODO: comparar con el greedy
% TODO: ¿comparar con fuerza bruta mal enfocada?