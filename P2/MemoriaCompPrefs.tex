\section{Comparación de preferencias}

En esta sección se presentan algoritmos que cumplen:
\begin{description}
	\item[Entrada:] Vector \texttt{v} y su tamaño \texttt{n}
	\item[Salida:] Entero no negativo que indica el número de pares $i,j$ de posiciones del vector tales que $i < j$ y $v[i] > v[j]$
\end{description}

\subsection{Algoritmo obvio}

El algoritmo que hemos considerado obvio para comprobar el número de inversiones es el siguiente, que simplemente comprueba todas las parejas posibles y añade $1$ a un contador para cada pareja invertida:

\lstinputlisting[firstline=24, lastline=32]{cpps/preferencias.cpp}

Como consecuencia de que el contenido del bucle interno se ejecuta $\displaystyle \sum_{i=0}^{n-2} n-i+1 = \frac{n^2}{2}+\frac{(3n)}{2}-2 $ veces, es un algoritmo de orden de eficiencia $O(n^2)$.

\subsection{Inversiones y algoritmos de ordenación: Divide y Vencerás}

No pudimos evitar darnos cuenta de la proximidad de nuestro problema con la de una ordenación de datos normal y corriente. Al ordenar datos, se deshacen las inversiones, y si hay un algoritmo de ordenación que facilite seguir la pista al proceso de deshacer inversiones, podemos aprovecharlo para contar el número de inversiones efectuado.
Es por esto que buscamos un algoritmo de ordenación que se pareciese lo máximo posible a nuestro problema. \\

El primer candidato fue el \textit{quicksort} por su rapidez. Sin embargo, no es adecuado para ayudarnos con esta cuestión, pues presenta un comportamiento difícil de controlar en cuanto a inversiones, dado que puede añadir inversiones en el proceso. \\ 

A continuación analizamos el algoritmo \textit{heapsort} dado que nos pareció que las propiedades del \textit{heap}, un árbol parcialmente ordenado, podrían arrojar algo de luz al problema; aunque al final resultó que precisamente la estructura de árbol lo hacía un inadecuado candidato. \\

Por último llego el turno del \textit{mergesort}. Este algoritmo divide el vector original en subvectores, combinando las soluciones. Pero tiene una forma de hacerlo más simple que el resto: tanto en el caso base (en el que se usará inserción) como en la mezcla de vectores podemos controlar el número de inversiones deshechas. \\

Por debajo de un cierto umbral aplicamos el algoritmo de ordenación por inserción, un algoritmo que en cada uno de sus pasos deshace una inversión, por lo que puede usarse este mismo algoritmo para contar el número de inversiones con una variable que se incremente a cada inversión realizada. Resulta más rápido que el algoritmo trivial en este menester, pero sigue siendo $O(n^2)$, y, curiosamente, al usar optimización se invierten los papeles y el algoritmo trivial es más rápido que el algoritmo de inserción. \\

A la hora de mezclar vectores también puede controlarse el número de inversiones deshechas. Consideremos un vector $T$, lo partimos en dos y aplicamos inserción a cada una de sus partes: izquierda ($U$) y derecha ($V$). Se observa que, al ordenar cada parte, las inversiones de los elementos de una parte respecto de elementos de la otra se conservan. Por ello, si en la mezcla de dos vectores $U$ y $V$ se inserta un elemento de $V$ cuando quedan $k$ elementos de $U$ por insertar, se estarán deshaciendo $k$ inversiones. Entonces el número de inversiones de $T$ será el número de inversiones de $U$ más el número de inversiones de $V$ más la suma de cada $k$ obtenido en cada inserción de un elemento de $V$ en la mezcla.\\

Veamos un ejemplo:

$$ \{5,4,3,2,1\}$$

El elemento $a_i$ de está lista está invertido $n-i$ veces con respecto a los demás. Apliquemos el $mergesort$:

$$ \{5,4,3\} \hspace{1cm} \{2,1\}$$

Si lo ordenamos los elementos del vector izquierdo siguen estando invertidos con respecto a los del derecho:

$$\{3,4,5\} \hspace{1cm} \{1,2\}$$

Ahora unamos las soluciones. Tomamos un índice al principio de cada vector; empezamos añadiendo elementos de $U$ hasta que encontremos uno de $V$ menor. Si $j$ es el indice de $U$ por el que nos hemos parado y $n$ su tamaño, el elemento que vamos añadir de $V$ está invertido con respecto de $n-(j-1)$ elementos del vector $U$.

Por tanto el número de inserciones de un vector es igual al de $U$ más el de $V$ más el de los contados al unir las soluciones. 

Mediante este razonamiento y una leve modificación del algoritmo \textit{mergesort} obtenemos una mejora sustancial al algoritmo trivial; una solución Divide y Vencerás de orden $O(n\cdot \log(n))$, que usa el algoritmo de inserción por debajo de cierto umbral.

\subsection{Determinación del umbral}

Se ha hallado el umbral óptimo en el siguiente contexto:

\spec{Darío}{\href{http://ark.intel.com/products/75116}{Intel\textregistered\ Core\texttrademark\ i7-4700HQ}}{2.40}{12}{Ubuntu 14.04 64 bits}{0}

Para hallar el umbral se han obtenido los tiempos de ejecución del algoritmo de inserción con conteo de número de inversiones (que se usará como caso básico para el Divide y Vencerás) y los tiempos de ejecución del algoritmo Divide y Vencerás basado en \textit{mergesort} con umbral 2 (es decir, aplicando Divide y Vencerás siempre excepto con subvectores de tamaño 2), con los siguientes tiempos en segundos:

\begin{tabular}{|l|l|l|}
	\hline
	Tamaño & Inserción & Mergesort \\
	\hline
	$10 $ & $1.854\cdot 10^{-6} $ & $3.202\cdot 10^{-6} $ \\ \hline
	$20 $ & $3.563\cdot 10^{-6} $ & $4.32\cdot 10^{-6}  $ \\ \hline
	$30 $ & $6.224\cdot 10^{-6} $ & $5.936\cdot 10^{-6} $ \\ \hline
	$40 $ & $8.78\cdot 10^{-6}  $ & $7.335\cdot 10^{-6} $ \\ \hline
	$50 $ & $1.7545\cdot 10^{-5}$ & $9.148\cdot 10^{-6} $ \\ \hline
	$60 $ & $1.1386\cdot 10^{-5}$ & $1.1253\cdot 10^{-5}$ \\ \hline
	$70 $ & $1.445\cdot 10^{-5} $ & $1.2554\cdot 10^{-5}$ \\ \hline
	$80 $ & $1.9508\cdot 10^{-5}$ & $1.4165\cdot 10^{-5}$ \\ \hline
	$90 $ & $2.6295\cdot 10^{-5}$ & $1.623\cdot 10^{-5} $ \\ \hline
	$100$ & $2.8818\cdot 10^{-5}$ & $1.701\cdot 10^{-5} $ \\ \hline
	$110$ & $3.0415\cdot 10^{-5}$ & $1.9441\cdot 10^{-5}$ \\ \hline
	$120$ & $3.6658\cdot 10^{-5}$ & $2.1167\cdot 10^{-5}$ \\ \hline
	$130$ & $4.206\cdot 10^{-5} $ & $2.2692\cdot 10^{-5}$ \\ \hline
	$140$ & $4.5831\cdot 10^{-5}$ & $2.4568\cdot 10^{-5}$ \\ \hline
	$150$ & $4.7527\cdot 10^{-5}$ & $2.6135\cdot 10^{-5}$ \\ \hline
	$160$ & $5.6566\cdot 10^{-5}$ & $2.8087\cdot 10^{-5}$ \\ \hline
	$170$ & $6.4559\cdot 10^{-5}$ & $3.0172\cdot 10^{-5}$ \\ \hline
	$180$ & $7.1696\cdot 10^{-5}$ & $3.1465\cdot 10^{-5}$ \\ \hline
	$190$ & $8.0769\cdot 10^{-5}$ & $6.2223\cdot 10^{-5}$ \\ \hline
	$200$ & $8.2839\cdot 10^{-5}$ & $3.5039\cdot 10^{-5}$ \\ \hline
\end{tabular} \\

El tiempo de ejecución del algoritmo basado en la ordenación por inserción se ajusta a la función $i(n) = 1.56413 \cdot 10^{-9} n^2 + 9.84525 \cdot 10^{-8} n + 2.08435 \cdot 10^{-6}$, mientras que el tiempo obtenido con el algoritmo derivado del \textit{mergesort} (ignorando el resultado obtenido en tamaño $190$) tiene por función de ajuste $m(n) = 3.08096 \cdot 10^{-8} n \cdot \log(n) + 3.07834 \cdot 10^{-6}$. Hallamos el punto de corte usando la función \texttt{find\_root} de Maxima: 

\begin{lstlisting}
	i(n):=1.56413*10^(-9)*n^2 + 9.84525 * 10^(-8)* n + 2.08435 *10^(-6)$
	m(n):=3.08096*10^(-8) *n*log(n) + 3.07834*10^(-6)$
	find_root(m(x)-i(x),x,10,200);
\end{lstlisting}

Obteniendo el punto de corte $25.726267$.

% TODO: gráficas, posiblemente con el ajuste añadido.

% TODO: A ver qué pasa, que a Darío le salía otro ajuste distinto para el DyV (el que está en el .cpp) y 50 como umbral óptimo (yo he tenido que omitir un valor porque estaba muy fuera).

\subsection{Comparación de algoritmos}
