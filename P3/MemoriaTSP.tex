\section{El problema del viajante de comercio}

El problema del viajante de comercio consiste en hallar el recorrido con distancia
mínima en un conjunto de ciudades que pase por todas las ciudades y regrese al punto
inicial. \\

La implementación de los algoritmos es de la forma:
\begin{description}
 \item[Entrada:] Ficheros con ciudades indicadas como puntos en el plano según sus
 coordenadas.
 \item[Salida:] \texttt{vector<int>} con el orden en el que se recorren las ciudades.
\end{description}

En la salida nos ahorraremos repetir el primer nodo al final del recorrido.

Para todos los algoritmos utilizaremos una estructura de datos que nos permita manejar
el problema: la clase \texttt{Grafo} (en el fichero \texttt{grafo.h}). Un grafo consta
de:

\begin{itemize}
  \item Una \textbf{cantidad de nodos}, almacenada en el atributo \texttt{nodos}.
  \item Una \textbf{matriz de pesos}, almacenada en el vector \texttt{lados}.
\end{itemize}

La interfaz nos permite acceder y modificar estos datos con mayor facilidad.
Mediante los métodos \texttt{setPeso} y \texttt{peso} accederemos al peso de un
lado del grafo, y el método \texttt{pesosDesdeCoordenadas} nos permite inicializar el
grafo utilizando el formato de datos en el que aparece el problema: calculando
la distancia entre cualesquiera dos ciudades y añadir esta como peso de ese lado:

\lstinputlisting[firstline=47, lastline=51]{cpps/grafo.h}

Adicionalmente, la función \texttt{longitud} calcula la longitud de un camino dado,
teniendo en cuenta la distancia del último nodo al primero:

\lstinputlisting[firstline=54, lastline=59]{cpps/grafo.h}

Siendo \texttt{peso\_t} el tipo de dato con el que se manejen las distancias entre
nodos. Según el enunciado del problema (que pide que se redondee la distancia
euclídea al entero más próximo), será de tipo \texttt{int}.

\subsection{Algoritmos}

\subsubsection{Vecino más cercano}

Utilizando la estructura de datos explicada anteriormente, la resolución del problema
utilizando la heurística del vecino más cercano quedará:

\lstinputlisting[firstline=17, lastline=40]{cpps/tsp.cpp}

Tomamos como ciudad inicial el nodo 0 y almacenamos en la lista \texttt{disponibles}
las ciudades no visitadas. A continuación, mientras queden ciudades disponibles,
recorremos la lista buscando aquella ciudad con distancia mínima a la última, la
cual añadimos al trayecto y eliminamos de la lista de disponibles.

\subsubsection{Estrategias de inserción}

Para las estrategias de inserción realizamos el trabajo en 3 etapas.
En primer lugar hallamos las 3 ciudades que conforman el \textbf{recorrido inicial}.
Para ello basta tomar las ciudades como coordenadas en el plano y tomar las ciudades
más al norte, este y oeste (tomando los puntos con menor y mayor coordenada x y mayor
coordenada y):

\lstinputlisting[firstline=42, lastline=65]{cpps/tsp.cpp}

En el caso en el que el punto de mayor coordenada y sea también el de mayor (o menor)
coordenada x cogeremos el segundo con mayor (o menor) coordenada x.


Una vez conseguido un triángulo en el grafo lo suficientemente grande lo siguiente es añadir el resto de ciudades. Utilizaremos el siguiente procedmiento a la hora de insertar.

\begin{itemize}
	\item{Recorrer la lista de nodos disponibles}
	\item{Para cada nodo seleccionar el indice en el que, de insertarse aumente lo menos posible el peso del grafo}
	\item{Insertamos en dicho indice el nodo que menos aumente el peso total}
\end{itemize}

\lstinputlisting[firstline = 93, lastline = 126]{cpps/tsp.cpp}
\newpage
El verdadero coraz\'on del algoritmo reside en saber qu\'e cómo varía el peso del grafo al insertar un nodo.
Consideremos lo siguiente: \\

Sea $y_0$ el nodo a insertar entre los nodos $n_i$ y $n_{i-1}$. Al hacer esta inserción el vértice que une los dos nuevos nodos desaparece y aparecen dos más: $(y_0 \vee n_i)$ y $(y_0 \vee n_{i-1})$.\\

Por tanto el peso de la inserción de $n_0$ en el indice $i$ es:
$$ \operatorname{PesoInsercion}_i = \operatorname{Peso}(y_0 \vee n_i)+\operatorname{Peso}(y_0 \vee n_i)-\operatorname{Peso}(n_i\vee n_{i-1})$$

Primero buscamos cual es el peso mínimo de insertar el nodo $n_i$ y lo comparamos con los demás. Insertamos el nodo cuyo peso mínimo sea menor en su índice correspondiente.


%% TODO: Explicación del resto de la estrategia

\subsubsection{Colonia de hormigas}

Como solución adicional propuesta por el equipo utilizamos un algoritmo basado en
colonias de hormigas. Este algoritmo se inspira en la comunicación por feromonas
de una colonia de hormigas para encontrar el camino mínimo hacia una fuente de comida. \\

Implementamos la Colonia (en el fichero \texttt{colonia.h}). Una Colonia consta de:

\begin{itemize}
  \item Un grafo de \textbf{distancias} entre las ciudades.
  \item Un grafo con las \textbf{feromonas} de cada camino, inicialmente arbitrarias.
  \item Una serie de constantes $\alpha, \beta, \rho, C, P$.
\end{itemize}

Las constantes controlan el comportamiento del algoritmo:

\begin{description}
  \item[$\alpha$] es el peso que tienen las feromonas.
  \item[$\beta$] es el peso que tienen la distancias.
  \item[$\rho$] es el coeficiente de evaporación de las feromonas.
  \item[$C$] determina cuánta feromona se añade a un camino.
  \item[$P$] es un flotante entre $0$ y $1$. Durante el progreso de un recorrido, hay
  una probabilidad de $1-P$ de que la hormiga opte por tomar directamente el camino
  más corto a otro nodo.
\end{description}

\subsection{Comparativa de los algoritmos}
