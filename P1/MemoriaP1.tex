\documentclass[a4paper, 11pt]{article}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[vmargin=2cm,hmargin=2cm]{geometry}
\usepackage{graphicx}
\graphicspath{{img/}}
\usepackage{accents}
\usepackage{framed}

\newcommand{\spec}[4]{
\bgroup
\def\arraystretch{1.3}
\begin{tabular}{|l|}
\hline
%Hardware y SO empleado:\\
CPU: #1 @#2 GHz\\RAM: #3 GB \hspace{0.8cm} SO: #4 \\
\hline
\end{tabular}
\egroup
\vspace*{0.3cm}
}

\title{\Huge \textbf{Práctica 1}}

\author{\textbf{Pablo Baeyens Fernández} \\ \textbf{Antonio Checa Molina} \\
\textbf{Iñaki Madinabeitia Cabrera} \\  \textbf{José Manuel Muñoz Fuentes} \\
 \textbf{Darío Sierra Martínez} \\ }

\date{Algorítmica}

\begin{document}

\maketitle
\tableofcontents

\newpage
\section{Ejercicio 1}
En el ejercicio 1 se nos pide hallar la eficiencia empírica de los algoritmos
presentados en la sesión. Para ello hemos modificado los códigos de los programas
para que tengan como salida el tamaño que se les pasó como argumento junto al tiempo
que han tardado en realizar la tarea del respectivo algoritmo.
Usando la biblioteca \textit{chrono} y la estructura que se menciona en la
sesión se consiguen medir los tiempos de los programas de forma precisa. \\

Una vez hecho esto, se elaboró un script de bash para automatizar la ejecución de
cada algoritmo con varios tamaños y recoger todas las salidas en un archivo para
luego poder usar esos datos. El script es el siguiente:


\begin{framed}

	\# !/bin/bash

	\# Uso: nombredelejecutable inicial salto final

	\# Ejemplo: fibonacci 10 5 80 ejecuta fibonacci 10, fibonacci 15, ..., fibonacci 80

	\# Salida: nombredelejecutable.dat
	\vspace{0.3cm}

	$>$ \$(basename \$1 .exe).dat

	for i in \$(seq \$2 \$3 \$4); do

	\hspace{0.4cm}./\$1 \$i $>>$ \$(basename \$1 .exe).dat

	done

\end{framed}

Las tablas generadas con este proceso se presentan a continuación, habiendo una tabla
para cada orden de eficiencia y una última tabla que reúne los tiempos de todos los
algoritmos de ordenación. \\

Todos los tiempos que se muestran en las tablas están en segundos, mientras que
\textit{Tamaño} menciona el tamaño total de la muestra con la que se obtuvo cada
tiempo de ejecución: en los algoritmos de ordenación hace referencia a la
capacidad del vector que se ordenaba, mientras que en Fibonacci o Hanói hace
referencia a las iteraciones totales del programa. \\

Debido al tamaño de las tablas (ya que cada una debía tener al menos 25 entradas),
cada tabla se muestra en una página. \\

Cabe destacar que la diferencia entre algoritmos de ordenación de un orden y de
otro resulta tan pronunciada que los algoritmos de orden $n \cdot \log (n)$ se
han ejecutado una segunda vez con un rango de valores en el que obtienen tiempos
de ejecución minúsculos, muchos órdenes de magnitud por debajo del obtenido por
los otros algoritmos de ordenación. En la tabla en la que se presentan se usan
tamaños mucho mayores, mientras que en la tabla comparativa de algoritmos de
ordenación toman estos mismos valores.

\subsection{Tabla del algoritmo de burbuja}
\input{tablas/burbuja_tabla}

\subsection{Tabla del algoritmo de selección}
\input{tablas/seleccion_tabla}

\subsection{Tabla del algoritmo de inserción}
\input{tablas/insercion_tabla}

\subsection{Tabla de los algoritmos cuadráticos}

Incluimos una tabla comparando los datos de una sóla persona para los algoritmos
de orden cuadrático:

\begin{tabular}{|l|l|l|l|}
	\hline
	Tamaño &Tiempo de Burbuja &Tiempo de  Inserción &Tiempo de  Selección \\
	\hline
	\hline
	2000 & 0,0141 & 0,005 & 0,0057 \\
	\hline
	4000 & 0,0516 & 0,0211 & 0,023 \\
	\hline
	6000 & 0,1138 & 0,0423 & 0,0485 \\
	\hline
	8000 & 0,203 & 0,0749 & 0,0853 \\
	\hline
	10000 & 0,3178 & 0,1194 & 0,1335 \\
	\hline
	12000 & 0,4675 & 0,1719 & 0,1922 \\
	\hline
	14000 & 0,6378 & 0,2302 & 0,2608 \\
	\hline
	16000 & 0,8319 & 0,3068 & 0,3446 \\
	\hline
	18000 & 1,0515 & 0,3948 & 0,4365 \\
	\hline
	20000 & 1,2976 & 0,4715 & 0,5323 \\
	\hline
	22000 & 1,5667 & 0,5756 & 0,6479 \\
	\hline
	24000 & 1,8566 & 0,6691 & 0,7654 \\
	\hline
	26000 & 2,1866 & 0,8164 & 0,9028 \\
	\hline
	28000 & 2,5267 & 0,9151 & 1,0435 \\
	\hline
	30000 & 2,9087 & 1,0581 & 1,2003 \\
	\hline
	32000 & 3,3202 & 1,1995 & 1,3639 \\
	\hline
	34000 & 3,7281 & 1,3595 & 1,5385 \\
	\hline
	36000 & 4,1982 & 1,5143 & 1,723 \\
	\hline
	38000 & 4,6725 & 1,684 & 1,9174 \\
	\hline
	40000 & 5,1504 & 1,8823 & 2,1246 \\
	\hline
	42000 & 5,6988 & 2,0988 & 2,3405 \\
	\hline
	44000 & 6,2511 & 2,2693 & 2,5674 \\
	\hline
	46000 & 6,8294 & 2,4624 & 2,8047 \\
	\hline
	48000 & 7,4305 & 2,6661 & 3,054 \\
	\hline
	50000 & 8,0857 & 2,9284 & 3,3125 \\
	\hline
\end{tabular}

\subsection{Tabla del algoritmo Heapsort}
\input{tablas/heapsort_tabla}
\subsection{Tabla del algoritmo Mergesort}
\input{tablas/mergesort_tabla}
\subsection{Tabla del algoritmo Quicksort}
\input{tablas/quicksort_tabla}

\subsection{Tabla de los algoritmos $n\cdot \log(n)$}

Incluimos una tabla comparando los datos de una sóla persona para los algoritmos
de orden $n\cdot \log(n)$:

\begin{tabular}{|l|l|l|l|}
	\hline
	Tamaño & Tiempo de Heapsort & Tiempo de Mergesort & Tiempo de Quicksort \\
	\hline
	\hline
	1000000	&0,158862&	0,25279&	0,245436\\
	\hline
	2000000	&0,333955&	0,55784	&0,508929\\
	\hline
	3000000	&0,512390&	0,92310	&0,883956\\
	\hline
	4000000	&0,689444&	1,26719	&1,068840\\
	\hline
	5000000	&0,875720&	1,66226	&1,422010\\
	\hline
	6000000	&1,063160&	2,06275	&1,804380\\
	\hline
	7000000	&1,254210&	2,46109	&1,880770\\
	\hline
	8000000	&1,448250&	2,89135	&2,214050\\
	\hline
	9000000	&1,636350&	3,30651	&2,563270\\
	\hline
	10000000	&1,802540&	3,69426	&2,943020\\
	\hline
	11000000	&2,013440&	4,14343	&3,320140\\
	\hline
	12000000	&2,211360&	4,60380	&3,736370\\
	\hline
	13000000	&2,399370&	5,06756	&4,035230\\
	\hline
	14000000	&2,589330&	5,51359	&3,893640\\
	\hline
	15000000	&2,786440&	5,96415	&4,248670\\
	\hline
	16000000	&2,984850&	6,40422	&4,579140\\
	\hline
	17000000	&3,174740&	6,93151	&4,953660\\
	\hline
	18000000	&3,358080&	7,39067	&5,305020\\
	\hline
	19000000	&3,563030&	7,85371	&5,679610\\
	\hline
	20000000	&3,803150&	8,35113	&6,070570\\
	\hline
	21000000	&3,950770&	8,85375	&6,459050\\
	\hline
	22000000	&4,171410&	9,26481	&6,862640\\
	\hline
	23000000	&4,371020&	9,70679	&7,275080\\
	\hline
	24000000	&4,558990&	10,26190	&7,763610\\
	\hline
	25000000	&4,774830&	10,71420	&8,117880\\
	\hline
\end{tabular}

\subsection{Tabla del algoritmo cúbico (Floyd)}
   \input{tablas/floyd_tabla}

\subsection{Tabla del algoritmo de Fibonacci $(O(\frac{1+\sqrt{5}}{2})^n)$}
   \input{tablas/fibonacci_tabla}

\subsection{Tabla del algoritmo de Hanoi ($O(2^n)$)}
   \input{tablas/hanoi_tabla}

\subsection{Tabla de los algoritmos de ordenación}

\begin{tabular}{|l|l|l|l|l|l|l|}
	\hline
	Tamaño	&Burbuja&	Inserción&	Selección&	Heapsort&	Mergesort&	Quicksort\\
	\hline
	\hline
	2000&	0,014089400&	0,00501	&0,005698&	0,000235&	0,000272&	0,000255\\
	\hline
	4000&	0,051553600&	0,02113	&0,022951&	0,000509&	0,000580&	0,000381\\
	\hline
	6000&	0,113751000&	0,04231&	0,048492&	0,000883&	0,001106&	0,000627\\
	\hline
	8000&	0,202951000&	0,07491&	0,085303&	0,001128&	0,001366&	0,000811\\
	\hline
	10000&	0,317834000&	0,11939&	0,133457&	0,001417&	0,001760&	0,001152\\
	\hline
	12000&	0,467509000&	0,17190&	0,192178&	0,001813&	0,002363&	0,001354\\
	\hline
	14000&	0,637843000&	0,23016&	0,260748&	0,002180&	0,002288&	0,001517\\
	\hline
	16000&	0,831875000&	0,30682&	0,344565&	0,002435&	0,002648&	0,001768\\
	\hline
	18000&	1,051490000&	0,39484&	0,436515&	0,002733&	0,003157&	0,001986\\
	\hline
	20000&	1,297600000&	0,47146&	0,532265&	0,003284&	0,003823&	0,002305\\
	\hline
	22000&	1,566720000&	0,57562&	0,647896&	0,003487&	0,004252&	0,002436\\
	\hline
	24000&	1,856610000&	0,66907&	0,765415&	0,003741&	0,004980&	0,002720\\
	\hline
	26000&	2,186600000&	0,81644&	0,902801&	0,004212&	0,004381&	0,002916\\
	\hline
	28000&	2,526680000&	0,91512&	1,043460&	0,004471&	0,004894&	0,003335\\
	\hline
	30000&	2,908670000&	1,05814&	1,200250&	0,004781&	0,005159&	0,003443\\
	\hline
	32000&	3,320190000&	1,19949&	1,363910&	0,005306&	0,005530&	0,003685\\
	\hline
	34000&	3,728090000&	1,35952&	1,538500&	0,005509&	0,006219&	0,003967\\
	\hline
	36000&	4,198150000&	1,51431&	1,723020&	0,005901&	0,006601&	0,004178\\
	\hline
	38000&	4,672490000&	1,68403&	1,917410&	0,006102&	0,007015&	0,004356\\
	\hline
	40000&	5,150410000&	1,88228&	2,124580&	0,006620&	0,007535&	0,004715\\
	\hline
	42000&	5,698770000&	2,09879&	2,340510&	0,006936&	0,008117&	0,004858\\
	\hline
	44000&	6,251140000&	2,26926&	2,567410&	0,007331&	0,009466&	0,005189\\
	\hline
	46000&	6,829350000&	2,46238&	2,804650&	0,007502&	0,009306&	0,005421\\
	\hline
	48000&	7,430450000&	2,66613&	3,053950&	0,007841&	0,009883&	0,005697\\
	\hline
	50000&	8,085720000&	2,92835&	3,312500&	0,008407&	0,010657&	0,005931\\
	\hline
\end{tabular}

\newpage
\section{Ejercicio 2}

En el ejercicio 2 se pide realizar las gráficas de los algoritmos, que hemos
realizado metiendo en \textit{gnuplot} los datos mostrados en las tablas anteriores,
con los siguientes resultados:

\subsection{Gráfica de los algoritmos cuadráticos}
\begin{figure}[h] \includegraphics[width=11cm]{comparativa_cuadraticos_g} \centering
	\caption{Algoritmos cuadráticos} \end{figure}

\begin{figure}[h] \includegraphics[width=11cm]{burbuja_todos_g} \centering
      \caption{Algoritmo de burbuja} \end{figure}

\begin{figure}[h] \includegraphics[width=11cm]{seleccion_todos_g} \centering
      \caption{Algoritmo de selección} \end{figure}

\begin{figure}[h] \includegraphics[width=11cm]{insercion_todos_g} \centering
      \caption{Algoritmo de inserción} \end{figure}

El algoritmo de la burbuja requiere más del doble de tiempo que cualquiera de los otros dos, que se encuentran casi igualados, teniendo un menor tiempo el de inserción. Probablemente este menor tiempo sea el motivo de que en \textit{quicksort} y \textit{mergesort} se use el algoritmo de inserción para subvectores pequeños.

\subsection{Gráfica de los algoritmos $n\cdot log(n)$ }
\begin{figure}[h] \includegraphics[width=11cm]{comparativa_logaritmicos_g} \centering
	\caption{Algoritmos  $n\cdot log(n)$} \end{figure}

En el algoritmo \textit{mergesort} se aprecian pequeños escalones. Probablemente en cada escalón se incrementa el número de llamadas recursivas, de forma que el tamaño de los subvectores para los que se llama a la función de ordenado por selección (que actúa para tamaños de entrada pequeños) es menor. \\
El algoritmo \textit{quicksort} también usa el algoritmo de inserción por debajo de cierto umbral, pero usa un umbral más pequeño. Esto puede ser la causa de que no presente los escalones.

\begin{figure}[h] \includegraphics[width=11cm]{mergesort_todos_g} \centering
   \caption{Algoritmo Mergesort} \end{figure}

\begin{figure}[h] \includegraphics[width=11cm]{quicksort_todos_g} \centering
   \caption{Algoritmo Quicksort} \end{figure}

\begin{figure}[h] \includegraphics[width=11cm]{heapsort_todos_g} \centering
   \caption{Algoritmo Heapsort} \end{figure}

\newpage
\subsection{Gráfica del algoritmo de Floyd (cúbico)}
\begin{figure}[h] \includegraphics[width=13cm]{floyd_todos_g} \centering
	\caption{Algoritmo de Floyd (cúbico)} \end{figure}

\subsection{Gráfica del algoritmo de Fibonacci $(O(\frac{1+\sqrt{5}}{2})^n)$}
\begin{figure}[h] \includegraphics[width=13cm]{fibonacci_todos_g} \centering
	\caption{Algoritmo de Fibonacci} \end{figure}

\newpage
\subsection{Gráfica del algoritmo de Hanoi ($O(2^n)$)}
\begin{figure}[h] \includegraphics[width=13cm]{hanoi_todos_g} \centering
	\caption{Algoritmo de Hanoi} \end{figure}


\subsection{Gráfica de los algoritmos de ordenación}
\begin{figure}[h] \includegraphics[width=14cm]{comparativa_global_g} \centering
	\caption{Algoritmos de ordenación} \end{figure}

La diferencia en el tiempo de ejecución de los algoritmos de un orden de eficiencia y de otro provoca que los tiempos de los algoritmos de orden de eficiencia $n \cdot \log (n)$ se muestren como una línea horizontal.

\newpage
\section{Ejercicio 3}

\subsection{Eficiencia híbrida de los algoritmos cuadráticos}

\begin{tabular}{|l|l|l|l|}
	\hline
	Persona & Burbuja & Inserción & Selección \\
	\hline
   Darío &$89\cdot10^{-3} -1.61671\cdot10^{-5}\cdot x +3\cdot10^{-9}\cdot x^2$ &$89 \cdot 10^{-3}+-1.6166\cdot10^{-5} \cdot x +1.68\cdot 10^{-9}\cdot x^2$&$89\cdot 10^{-3}-1.616\cdot 10^{-5}\cdot x +1.59 \cdot 10^{-9} \cdot x^2$ \\
   \hline
	José Manuel & $3.85\cdot 10^{-9}n^2 - 7.88\cdot 10^{-6}n + 0.013$ ($r=0.999998565269577$) & $1.32\cdot 10^{-9}n^2 + 4.95\cdot 10^{-7}n - 0.0024$ ($r=0.999979582960209$) & $1.59\cdot 10^{-9}n^2 + 2.93 \cdot 10^{-7} n - 0.0022$ $(r=0.999996280002182)$ \\
   \hline
	Pablo & $3\cdot 10^{-9}n^2 -6\cdot 10^{-6}n + 0,015$ ($r=0.99$) & $10^{-9}n^2 + 4\cdot 10^{-7}n + 0,002$ ($r=0.99$) & $10^{-9}n^2 -2\cdot 10^{-7}n + 0,004$ ($r=1$) \\
	\hline
\end{tabular}

\subsection{Eficiencia híbrida de los algoritmos $n \cdot \log(n)$}

\begin{tabular}{|l|l|l|l|}
	\hline
	Persona & Heapsort & Mergesort & Quicksort \\
	\hline
   Darío & $-0.00499364 +2.58544\cdot 10^{-8}\cdot x\cdot log(x)  $&$ -0.00499364 +3.0260\cdot 10^{-8}\cdot x\cdot log(x)$&$-0.00499364  +1.46227\cdot 10^{-8}\cdot x\cdot log(x) $\\
   \hline
   José Manuel & $3.13\cdot 10^{-8}n\log(n) - 0.37$ ($r=0.999702622004366$) & $2.29 \cdot 10^{-8}n\log(n) - 0.082$ ($r=0.997798964368601$) & $1.42 \cdot 10^{-8}n\log(n) + 0.020$ ($r=0.999963309603908$)\\
   \hline
	Pablo & $1.8 \cdot 10^{-8}n\log(n) -1.9\cdot 10^{-7}$ ($r=0.995$)  & $2 \cdot 10^{-8} n \log(n) - 1.9\cdot 10^{-7}$ ($r=0.997$)& $1.3 \cdot 10^{-8}n\log(n) -1.9\cdot 10^{-7}$ ($r=0.999$)\\	
	\hline
	
\end{tabular}

\subsection{Eficiencia híbrida del algoritmo de Floyd}
\begin{tabular}{|l|l|l|}
	\hline
	Persona & Eficiencia híbrida de Floyd & Coeficiente de correlación \\
   \hline
 Darío & $ -0.00499364 +0.000217346\cdot x+-7.6610\cdot 10^{-7} + 6.98242\cdot 10^{-9} $ \\
   \hline
 José Manuel & $ 6.88 \cdot 10^{-9}n^3 + 2.89 \cdot 10^{-7}n^2 -4.44 \cdot 10^{-5}n +0.001$ & $0.999960701767451$ \\
	\hline
 Pablo & $ 5.1 \cdot 10^{-9}n^3 + 3.8 \cdot 10^{-7}n^2 -8.3 \cdot 10^{-5}n +0.005$ & $1$ \\
 \hline

\end{tabular}

\subsection{Eficiencia híbrida del algoritmo de Fibonacci}
\begin{tabular}{|l|l|l|}
	\hline
	Persona & Eficiencia híbrida de Fibonacci & Coeficiente de correlación \\
	\hline
 Darío & $-0.00450426 +0.00150218\cdot\phi^x $\\
   \hline
 José Manuel & $3.81 \cdot 10^{-9} \frac{1 + \sqrt{5}}{2}^n +9.68\cdot 10^{-7}$ & $0.999939284564366$\\
   \hline
 Pablo & $6.4 \cdot 10^{-9} \frac{1 + \sqrt{5}}{2}^n -1.8\cdot 10^{-8}$ & $0.997$\\
 \hline
\end{tabular}

\subsection{Eficiencia híbrida del algoritmo de Hanoi}
\begin{tabular}{|l|l|l|}
	\hline
	Persona & Eficiencia híbrida de Hanoi & Coeficiente de correlación \\
	\hline
 Darío & $ -0.00499364+ 6.37556\cdot 10^{-9}\cdot 2^x$\\
   \hline
 José Manuel & $6.00 \cdot 10^{-9} 2^n + 9.3 \cdot 10^{-6}$ & $0.999999531007589$\\
   \hline
 Pablo & $6.1 \cdot 10^{-9} 2^n + 1.1 \cdot 10^{-9}$ & $0.9998$\\
 \hline
\end{tabular}

\end{document}

\subsection{Eficiencia hibrida: Comparativa}

Observaremos experimentalmente que si intentamos ajustar los datos de ejecución de los algoritmos con distintas funciones, la que produce un mejor ajuste es la que expresa su eficiencia en el caso medio.

Tomaremos un algoritmo tipo de cada clase de eficiencia y lo intentaremos ajustar mediante distintas curvas.

\textbf{Algoritmos cuadráticos}
